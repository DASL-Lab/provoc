% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/provoc_optim.R
\name{provoc_optim}
\alias{provoc_optim}
\title{Estimate the proportions of VOCs using Constrained Optimization}
\usage{
provoc_optim(coco, varmat, bootstrap_samples = 0)
}
\arguments{
\item{coco}{A data frame containing columns labelled count, coverage, and mutation.}

\item{varmat}{The variant matrix to be used in the study. The rownames must be the VoCs and the colnames must be the mutation names (in the same format as the mutation names in \code{coco})}

\item{bootstrap_samples}{The number of bootstrap samples to use.}
}
\value{
A list containing the results as well as convergence information from \code{constrOptim}.

\describe{
\item{res_df}{The estimated proportions of the variants of concern (\eqn{rho}), including CI if \code{bootstrap_samples > 0}}
\item{convergence}{Logical}
\item{convergence_note}{Convergence code from \code{constrOptim}. Also includes the method used for initializing \eqn{\rho}.}
}
}
\description{
If
}
\details{
The estimates are found by minimizing the squared difference between the frequency of each mutation and the prediction of a binomial model where the proportion is equal to the sum of rho times the relevant column of varmat and the size parameter is equal to the coverage.

The algorithm will first try a prior guess based on the current (March 2022) most common VOCs, then will try a uniform proportion, then (the nuclear option) will try 20 random perturbations until it works. Fails gracefully, with list elements indicating the convergence status and the initialization of rho, and returns the results that had the lowest value of the objective function.

Bootstrapping is performed parametrically, assuming that coverage is Poisson with a mean of the observed coverage and, based on the sampled value of the coverage, the count is sampled from a binomial distribution with proportion equal to that in the data.
}
\examples{
varmat <- simulate_varmat() # default values (Omicron)
varmat <- varmat[row.names(varmat) \%in\% c("B.1.1.529", "BA.1", "BA.2")]
coco <- simulate_coco(varmat, rel_counts = c(100, 200, 300)) # expect 1/6, 2/6, and 3/6
res <- copt_binom(coco, varmat)
res$res_df
}
\seealso{
\code{\link[stats]{constrOptim}}
}
